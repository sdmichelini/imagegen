# Frontend File Layout and esbuild Plan

## Goals

- Keep HTML server-rendered with clear reusable template structure.
- Keep CSS and JS modular by concern (tokens, components, pages).
- Build JS and CSS to hashed files in `dist/`.
- Generate `manifest.json` so templates can resolve hashed asset names.

## Proposed Project Layout

```text
web/
  templates/
    layouts/
      base.html
    partials/
      head.html
      nav.html
      flash.html
    pages/
      dashboard.html
      brands.html
      brand-edit.html
      projects.html
      project-detail.html
      work-item-detail.html

  static/
    css/
      src/
        tokens.css
        base.css
        components/
          card.css
          button.css
          form.css
          nav.css
        pages/
          dashboard.css
          brands.css
          project-detail.css
          work-item-detail.css
        app.css
    js/
      src/
        core/
          api.ts
          dom.ts
          events.ts
        pages/
          dashboard.ts
          brands.ts
          brand-edit.ts
          project-detail.ts
          work-item-detail.ts
        types/
          domain.ts
          ui.ts
        app.ts
    dist/                      # generated by esbuild; do not edit
      manifest.json
      *.js
      *.css
```

## Asset Responsibilities

- `templates/layouts/base.html`: page shell + asset includes.
- `templates/partials/*`: reusable chunks.
- `css/src/tokens.css`: all HSL tokens, type scale, spacing, shadows.
- `css/src/components/*`: card/button/form primitives.
- `css/src/pages/*`: page-level rules only.
- `css/src/app.css`: imports tokens/components/page styles for shared baseline.
- `js/src/core/*`: fetch helpers, DOM helpers, event wiring.
- `js/src/pages/*`: page-specific interactions.
- `js/src/types/*`: shared frontend type contracts.
- `js/src/app.ts`: global behavior (nav, toasts, common interactions).

## esbuild Setup

Place this at `web/esbuild.config.mjs`.

```js
import * as esbuild from 'esbuild';
import { mkdirSync, rmSync, writeFileSync } from 'fs';
import { basename } from 'path';

const outdir = 'web/static/dist';
const isWatch = process.argv.includes('--watch');

const common = {
  outdir,
  bundle: true,
  minify: true,
  sourcemap: false,
  entryNames: '[name]-[hash]',
  metafile: true,
  watch: isWatch ? {} : false,
};

rmSync(outdir, { recursive: true, force: true });
mkdirSync(outdir, { recursive: true });

const js = await esbuild.build({
  ...common,
  format: 'iife',
  entryPoints: [
    'web/static/js/src/app.ts',
    'web/static/js/src/pages/dashboard.ts',
    'web/static/js/src/pages/brands.ts',
    'web/static/js/src/pages/brand-edit.ts',
    'web/static/js/src/pages/project-detail.ts',
    'web/static/js/src/pages/work-item-detail.ts',
  ],
});

const css = await esbuild.build({
  ...common,
  entryPoints: [
    'web/static/css/src/app.css',
    'web/static/css/src/pages/dashboard.css',
    'web/static/css/src/pages/brands.css',
    'web/static/css/src/pages/project-detail.css',
    'web/static/css/src/pages/work-item-detail.css',
  ],
});

const manifest = {};

for (const [outputPath] of Object.entries(js.metafile.outputs)) {
  const file = basename(outputPath);
  const m = file.match(/^(.+?)-[A-Z0-9]+\.js$/i);
  if (m) manifest[`${m[1]}.js`] = file;
}

for (const [outputPath] of Object.entries(css.metafile.outputs)) {
  const file = basename(outputPath);
  const m = file.match(/^(.+?)-[A-Z0-9]+\.css$/i);
  if (m) manifest[`${m[1]}.css`] = file;
}

writeFileSync(`${outdir}/manifest.json`, JSON.stringify(manifest, null, 2));
console.log('Built assets:', manifest);
```

## package.json

Place this at `web/package.json`.

```json
{
  "private": true,
  "scripts": {
    "build": "node esbuild.config.mjs",
    "watch": "node esbuild.config.mjs --watch"
  },
  "dependencies": {
    "esbuild": "^0.24.0"
  }
}
```

## HTML Integration with Manifest

Use a backend template helper (example: `asset "app.css"`) that looks up `web/static/dist/manifest.json`.

```html
<link rel="stylesheet" href="/static/dist/{{ asset "app.css" }}">
<script src="/static/dist/{{ asset "app.js" }}" defer></script>
```

Guidelines:
- Never hardcode hashed filenames in templates.
- Keep one shared CSS (`app.css`) and one shared JS (`app.js`) for base UI.
- Include page-specific bundles only where needed.

## TypeScript Evolution

- JS modules should evolve to TypeScript while keeping the same entrypoint names for manifest stability.
- Preferred source path after migration: `web/static/js/src/**/*.ts`.
- Keep template asset keys logical (`app.js`, `brands.js`) even when sources are TS.

## Why This Layout

- Keeps design tokens centralized and reusable.
- Prevents page CSS/JS from becoming one large file.
- Supports fast cache busting through hashed outputs.
- Maintains simple server-rendered templates with minimal runtime complexity.
